
1. 이진수 

십진수를 생각해보면 0~9까지 10가지 레이블을 붙이기가 가능하다.
두자리 십진수는 00부터 99까지 100가지 레이블을 가능

실제로는 앞에 0이 있고(0034)=(34) 
앞에오는 0은 생략해서 표현하고 0이 아닌 1부터 레이블을 붙이기 시작한다.

비트를 3개를 가지고 값을 표현 하려면 2^3의 까지 8가지의 값을 레이블로 할당
할 수 있다.

이진수를 살펴보면 0과 1로 이루어져  101001 같은 수의 형태를 하고있다.
(1*2^5), (0*2^4), (1*2^3), (0*2^2), (0*2^1), (1*2^0) 와 같이 자리수를 가지고 있고 
앞의 수는 뒤의 수의 2배의 값을 가진다. (32 + 8 + 1 = 41)

위의 방법으로 이진수를 십진수로 바꾸는 것은 어렵지 않다. (2의 거듭제곱을 합산하면)

반대로 십진수를 이진수로 바꾸려면 조금 다른 방법을 이용하면 쉽다.

십진수를 값의 2로 나누며 나머지가 나오면 오른쪽부터 나머지를 쌓으면 된다.

75라고 하면 =>37*2+1 => 18*2+1 => 9*2~0 => 4*2+1 => 2*2~0 => 1*2~0 => 1
(이 수를 오른쪽부터 나머지 값 1001011이다.)

이진수는 이런 법칙을 가지고 이를 연산하는 것을 생각해보면 

1. 덧셈
이진수를 자리에 맞추어 더한 뒤 2가된 값은 
한자리 높은 자리의 수의 값이랑 같다.
그러면 2가 나온 값의 자리수를 한칸 올리면 된다.(이건 십진수의 덧셈과 같다.)
	  100101
	+101110
	=101211 => 102011  => 110011
2. 뺄셈
뺄셈은 같은 자리수를 빼 -1이되는 부분의 앞자리의 값이 
뒤로오면 2가 됨으로 뒤로 가져와 계산하면 된다.
(이 것도 십진수에서 했던 뺄샘이랑 같다.)
	  1 0 0 1 0 1
	  -  1 1 1 1 0
	= 1-1-1 0-1 1 => 1-1-1-1 1 1 => 1-1-2 1 1 1 => 1-2 0 1 1 1 => 0 0 0 1 1 1 => 111
3. 곱셈
곱셈은 두중에 곱하는 수를 자리수에 하나씩 곱합니다.
1001 * 1100 이라면 	###1100
			##0000#
			#0000##
			1100###
이라는 자리수를 덧셈하면 된다. 그러면 1101100가 된다.
(이것도 생각해보면 십진수의 계산 방법과 같다.)

이런식으로 생각하면 익숙하지 않고, 시각적으로 보기 힘들 뿐이지 계산은 간단하다.

4. 나눗셈
나눗셈은..... 곱셈의 반대인데.,,, 설명하자면 
반대로 1101100이 1100으로 나눈다 생각하면 앞에서 부터 나눌 때 
대응 되는 값을 빼면 된다. 
	    1
	1101100 	        1001
	1100### => 0001100
		     ###1100 => 0000000 (나머지)

1100을 앞에서 자리수 맞추어 빼면 1100이 남겠지?
빼지면 1주고 두자리 만큼 안빼지니까 00 그다음 1하면 된다..

이런식으로 나누어 떨어지지 않으면 뒤로 .을 붙이고 000이 개속 있다고 생각하면 된다.
(십진수의 계산 방법과 같다.), ()


2. 바이트 

단일 바이트는 256개의 구별되는 값을 인코딩 할 수 있다.
(인코딩(encoding) :  정보의 형태나 형식을 변환하는 처리나 처리 방식이다.)
(우리가 쓰는 문자를 컴퓨터의 언어의 값과 매칭시켜 컴퓨터가 이용할 수 있도록 만드는 것.)

바이트가 2개면 16비트로 2^16 즉 65,535개의 값을 나타낼 수 있다.

바이트로 나타낼 수 있는 정보의 종류에는 제한이 없다.
하지만 정보의 종류(문자, 숫자, 그외 등)에 특정그룹이 정의하고 처리하기 위한 명력어가 있다.
(예시 밑에)

개별 비트를 확인하기 위해 할때 이진수를 쓴다면 
비트 별로 다른 정보를 인코딩 한다면 이진 표기 방식이 더 필요한다.
(값을 정의하는 비트 + 정보의 종류의 정할 비트)
이러면 이진수 방법으로는 너무 길어진다, 그래서 십육진수라는 대안 표기법을 사용한다.
(0~9까지 그리고 A~ F까지로 표현)
십육진수는 4개의 비트로 표현된다. (F = 1111, 이라고 할 수 있겠지)

색을 표현 할때는 3원색 (적색, 녹색, 청색)의 비율을 조정하는 것으로 표현하는데.
일반적인 방법으로 한 픽셀에 3바이트의 사용해 각각의 바이트에 색의 256가지의 세기를 조정해
256*256*256 까지의 색을 나타나낼 수 있다.(2^24)
예로 컴퓨터에 색상을 표현할 때  FF0000 같은 값은 표현을 본적 있을 것이다.

색당 1바이트가(2^8) 주어지니 십육진수(2^4)로 
두자리를 가지고 앞에서 부터 두자리씩 색의 크기를 나타낸다.
(그러면 최대는 FF고 최소는 00이 될 것이다.),( FF0000의 색은 아주 선명한 적색이 되겠죠?)

컴퓨터는 내부적으로 다양한 크기의 데이터를 덩어리단위로 조작하고 
수를 표기 할때는 32비트 64비트가 편하게 사용된다.(주소도.)
(이래서 가끔 수를 표현할 때 한계를 마주하는 것은 이런 이유다. 아무리 커보이는 수라도 한계가 있다.)

32비트면 4GB의 메모리에 접근하기에는 충분하고
지금은 범용 컴퓨터가 32비트에서 64비트로 이행이 거의 되었다.

비트와 바이트에서 가장 기억해야 할 내용은 비트는 모여서 의미가 상황에 따라 결정된다는 것이다.
그냥 봐서는 무엇을 의미하는지 알 수 었다. (한개의 비트는 끄고 키고만 가능.)
(아까 설명 했던 정보의 종류가 비트로들로 주어지며 상황에 따라서 결정된다. )

(바이트 1개에서 8개의 비트 중 한개는 참과 거짓을 나타내고 7개는 사용되지 않을 수도 있다. )
(아니면 그냥 정수의 저장하거나, 아스키코드 같은 문자를 저장할 수도 있다.)

(어떤 프로그램의 데이터는 다른 프로그램의 명령어가 되기도 한다.)
=> {프로그램을 다운로드 할 때는 그냥 데이터 덩어리로 그냥 무작정 복사되었다가  
프로그램이 실행할 때 CPU(프로세서)가 정해진 방식으로 처리하면서 명령어가 된다.}

이제 내용을 요약하자면 

컴퓨터가 십진수 대신 2진수를 사용하는 이유는 

인간은 구분하는 능력이 뛰어나다. 시각적으로 짧고 생각이 필요한 십진수를 쓰는 것이고

컴퓨터는 빠르고 정확하고 개산이 빠르지만 군분하게 만들기 힘들어 2가지 상태만 인식하면 되는
 2진수를 쓰는 것이다.(스위치 처럼 켜지고 꺼지고만 인식하면 된다,)






